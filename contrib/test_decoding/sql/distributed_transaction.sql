-- Now Coordinator's logical decoding can decode distributed_forget logs.
-- This test-case is to verify this function.
-- Mainly use pg_logical_slot_get_changes to get the decoded distributed_forget log content
-- and verify whether the contents are as expected.

-- table and function defination
CREATE TABLE test_table(col_id int PRIMARY KEY, col_gxid xid);

-- pg_logical_slot_get_changes will get the decoded distributed_forget log.
-- We get the distributed-transaction-id and the number of segments executing the distributed transactions,
-- and check if they are correct.
-- This is an example of the content get by pg_logical_slot_get_changes:
-- 'DISTRIBUTED_FORGET 486272,3 segments'
-- These are generated by the pg_decode_distributed_forget function in test_decoding.c.
CREATE OR REPLACE FUNCTION test_distributed_forget() RETURNS text AS $$
DECLARE
  gxid int8;
  nsegs int;
  expect_change text;
  get_change_result text;
  ret text;
BEGIN
  BEGIN
    -- Get the actual gxid.
    SELECT col_gxid FROM test_table limit 1 INTO gxid;
    -- Get the actual number of segments executing the distributed transaction.
    select count(distinct gp_segment_id) from test_table into nsegs;
    select 'DISTRIBUTED_FORGET ' || gxid::text || ',' || nsegs::text || ' segments' into expect_change;

    SELECT data FROM pg_logical_slot_get_changes('regression_slot_p', NULL, NULL) INTO get_change_result;

    IF expect_change = get_change_result THEN
       ret := 'result match';
    ELSE
       ret := 'result not match';
    END IF;
  END;
  RETURN ret;
END;
$$ language plpgsql;

-- Start test
SELECT slot_name FROM pg_create_logical_replication_slot('regression_slot_p', 'test_decoding');

BEGIN;
INSERT INTO test_table SELECT * FROM generate_series(100,500,100);
update test_table set col_gxid = (SELECT * FROM gp_distributed_xid());
END;

SELECT * FROM test_distributed_forget();

-- Clean
DROP TABLE test_table;
SELECT pg_drop_replication_slot('regression_slot_p');
DROP FUNCTION test_distributed_forget;
